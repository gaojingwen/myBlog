{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{64:function(e,a,t){\"use strict\";t.r(a);var r=t(0),s=Object(r.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,a=e.$createElement,t=e._self._c||a;return t(\"div\",{staticClass:\"content\"},[t(\"h2\",{attrs:{id:\"es2018-新特征之：异步迭代器-for-await-of\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#es2018-新特征之：异步迭代器-for-await-of\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" ES2018 新特征之：异步迭代器 for-await-of\")]),e._v(\" \"),t(\"p\",[e._v(\"原创： justjavac [justjavac](javascript:void(0)😉 \"),t(\"em\",[e._v(\"2月26日\")])]),e._v(\" \"),t(\"h2\",{attrs:{id:\"_1-概述\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1-概述\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" 1. 概述\")]),e._v(\" \"),t(\"p\",[e._v(\"在 ECMAScript 2015(ES6) 中 JavaScript 引入了迭代器接口（iterator）用来遍历数据。迭代器对象知道如何每次访问集合中的一项， 并跟踪该序列中的当前位置。在 JavaScript 中迭代器是一个对象，它提供了一个 \"),t(\"code\",[e._v(\"next()\")]),e._v(\" 方法，用来返回序列中的下一项。这个方法返回包含两个属性： \"),t(\"code\",[e._v(\"done\")]),e._v(\" 和 \"),t(\"code\",[e._v(\"value\")]),e._v(\"。\")]),e._v(\" \"),t(\"p\",[e._v(\"迭代器对象一旦被创建，就可以反复调用 \"),t(\"code\",[e._v(\"next()\")]),e._v(\"。\")]),e._v(\" \"),t(\"div\",{staticClass:\"language- line-numbers-mode\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v(\"function makeIterator(array) {  let nextIndex = 0;  // 初始索引  // 返回一个迭代器对象，对象的属性是一个 next 方法  return {    next: function() {      if (nextIndex < array.length) {        // 当没有到达末尾时，返回当前值，并把索引加1        return { value: array[nextIndex++], done: false };      }      // 到达末尾，done 属性为 true      return {done: true};    }  };}\\n\")])]),e._v(\" \"),t(\"div\",{staticClass:\"line-numbers-wrapper\"},[t(\"span\",{staticClass:\"line-number\"},[e._v(\"1\")]),t(\"br\")])]),t(\"p\",[e._v(\"一旦初始化， \"),t(\"code\",[e._v(\"next()\")]),e._v(\" 方法可以用来依次访问对象中的键值：\")]),e._v(\" \"),t(\"div\",{staticClass:\"language- line-numbers-mode\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v(\"const it = makeIterator(['j', 'u', 's', 't']);it.next().value;  // jit.next().value;  // uit.next().value;  // sit.next().value;  // tit.next().value;  // undefinedit.next().done;   // trueit.next().value;  // undefined\\n\")])]),e._v(\" \"),t(\"div\",{staticClass:\"line-numbers-wrapper\"},[t(\"span\",{staticClass:\"line-number\"},[e._v(\"1\")]),t(\"br\")])]),t(\"h2\",{attrs:{id:\"_2-可迭代对象\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_2-可迭代对象\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" 2. 可迭代对象\")]),e._v(\" \"),t(\"p\",[e._v(\"一个定义了\"),t(\"strong\",[e._v(\"迭代行为\")]),e._v(\"的对象，比如在 \"),t(\"code\",[e._v(\"for...of\")]),e._v(\" 中循环了哪些值。为了实现可迭代，一个对象必须实现 \"),t(\"code\",[e._v(\"@@iterator\")]),e._v(\" 方法，这意味着这个对象（或其原型链中的一个对象）必须具有带 \"),t(\"code\",[e._v(\"Symbol.iterator\")]),e._v(\" 键的属性：\")]),e._v(\" \"),t(\"p\",[t(\"code\",[e._v(\"String\")]),e._v(\"， \"),t(\"code\",[e._v(\"Array\")]),e._v(\"， \"),t(\"code\",[e._v(\"TypedArray\")]),e._v(\"， \"),t(\"code\",[e._v(\"Map\")]),e._v(\" 和 \"),t(\"code\",[e._v(\"Set\")]),e._v(\" 都内置可迭代对象，因为它们的原型对象都有一个 \"),t(\"code\",[e._v(\"Symbol.iterator\")]),e._v(\" 方法。\")]),e._v(\" \"),t(\"div\",{staticClass:\"language- line-numbers-mode\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v(\"const justjavac = {  [Symbol.iterator]: () => {    const items = [`j`, `u`, `s`, `t`, `j`, `a`, `v`, `a`, `c`];    return {      next: () => ({        done: items.length === 0,        value: items.shift()      })    }  }}\\n\")])]),e._v(\" \"),t(\"div\",{staticClass:\"line-numbers-wrapper\"},[t(\"span\",{staticClass:\"line-number\"},[e._v(\"1\")]),t(\"br\")])]),t(\"p\",[e._v(\"当我们定义了可迭代对象后，就可以在 \"),t(\"code\",[e._v(\"Array.from\")]),e._v(\"、 \"),t(\"code\",[e._v(\"for...of\")]),e._v(\" 中使用这个对象：\")]),e._v(\" \"),t(\"div\",{staticClass:\"language- line-numbers-mode\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v('[...justjavac];// [\"j\", \"u\", \"s\", \"t\", \"j\", \"a\", \"v\", \"a\", \"c\"]Array.from(justjavac)// [\"j\", \"u\", \"s\", \"t\", \"j\", \"a\", \"v\", \"a\", \"c\"]new Set(justjavac);// {\"j\", \"u\", \"s\", \"t\", \"a\", \"v\", \"c\"}for (const item of justjavac) {  console.log(item)}// j // u // s // t // j // a // v // a // c\\n')])]),e._v(\" \"),t(\"div\",{staticClass:\"line-numbers-wrapper\"},[t(\"span\",{staticClass:\"line-number\"},[e._v(\"1\")]),t(\"br\")])]),t(\"h2\",{attrs:{id:\"_3-同步迭代\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_3-同步迭代\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" 3. 同步迭代\")]),e._v(\" \"),t(\"p\",[e._v('由于在迭代器方法返回时，序列中的下一个值和数据源的 \"done\" 状态必须已知，所以迭代器只适合于表示'),t(\"strong\",[e._v(\"同步\")]),e._v(\"数据源。\")]),e._v(\" \"),t(\"p\",[e._v(\"虽然 JavaScript 程序员遇到的许多数据源是同步的（比如内存中的列表和其他数据结构），但是其他许多数据源却不是。例如，任何需要 I/O 访问的数据源通常都会使用基于事件的或流式异步 API 来表示。不幸的是，迭代器不能用来表示这样的数据源。\")]),e._v(\" \"),t(\"p\",[e._v('（即使是 promise 的迭代器也是不够的，因为它的 value 是异步的，但是迭代器需要同步确定 \"done\" 状态。）')]),e._v(\" \"),t(\"p\",[e._v(\"为了给异步数据源提供通用的数据访问协议，我们引入了 \"),t(\"code\",[e._v(\"AsyncIterator\")]),e._v(\" 接口，异步迭代语句（ \"),t(\"code\",[e._v(\"for-await-of\")]),e._v(\"）和异步生成器函数。\")]),e._v(\" \"),t(\"h2\",{attrs:{id:\"_4-异步迭代器\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_4-异步迭代器\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" 4. 异步迭代器\")]),e._v(\" \"),t(\"p\",[e._v(\"一个异步迭代器就像一个迭代器，除了它的 \"),t(\"code\",[e._v(\"next()\")]),e._v(\" 方法返回一个 \"),t(\"code\",[e._v(\"{value,done}\")]),e._v(\" 的 promise。如上所述，我们必须返回迭代器结果的 promise，因为在迭代器方法返回时，迭代器的下一个值和“完成”状态可能未知。\")]),e._v(\" \"),t(\"p\",[e._v(\"我们修改一下之前的代码：\")]),e._v(\" \"),t(\"div\",{staticClass:\"language- line-numbers-mode\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v(\" const justjavac = {-  [Symbol.iterator]: () => {+  [Symbol.asyncIterator]: () => {     const items = [`j`, `u`, `s`, `t`, `j`, `a`, `v`, `a`, `c`];     return {-      next: () => ({+      next: () => Promise.resolve({         done: items.length === 0,         value: items.shift()       })     }   } }\\n\")])]),e._v(\" \"),t(\"div\",{staticClass:\"line-numbers-wrapper\"},[t(\"span\",{staticClass:\"line-number\"},[e._v(\"1\")]),t(\"br\")])]),t(\"p\",[e._v(\"好的，我们现在有了一个异步迭代器，代码如下：\")]),e._v(\" \"),t(\"div\",{staticClass:\"language- line-numbers-mode\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v(\"const justjavac = {  [Symbol.asyncIterator]: () => {    const items = [`j`, `u`, `s`, `t`, `j`, `a`, `v`, `a`, `c`];    return {      next: () => Promise.resolve({        done: items.length === 0,        value: items.shift()      })    }  }}\\n\")])]),e._v(\" \"),t(\"div\",{staticClass:\"line-numbers-wrapper\"},[t(\"span\",{staticClass:\"line-number\"},[e._v(\"1\")]),t(\"br\")])]),t(\"p\",[e._v(\"我们可以使用如下代码进行遍历：\")]),e._v(\" \"),t(\"div\",{staticClass:\"language- line-numbers-mode\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v(\"for await (const item of justjavac) {  console.log(item)}\\n\")])]),e._v(\" \"),t(\"div\",{staticClass:\"line-numbers-wrapper\"},[t(\"span\",{staticClass:\"line-number\"},[e._v(\"1\")]),t(\"br\")])]),t(\"p\",[e._v(\"如果你遇到了 \"),t(\"code\",[e._v(\"SyntaxError:forawait(...of...)isonly validinasyncfunctionsandasyncgenerators\")]),e._v(\" 错误，那是因为 \"),t(\"code\",[e._v(\"for-await-of\")]),e._v(\" 只能在 async 函数或者 async 生成器里面使用。\")]),e._v(\" \"),t(\"p\",[e._v(\"修改一下：\")]),e._v(\" \"),t(\"div\",{staticClass:\"language- line-numbers-mode\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v(\"(async function(){  for await (const item of justjavac) {    console.log(item)  }})();\\n\")])]),e._v(\" \"),t(\"div\",{staticClass:\"line-numbers-wrapper\"},[t(\"span\",{staticClass:\"line-number\"},[e._v(\"1\")]),t(\"br\")])]),t(\"h2\",{attrs:{id:\"_5-同步迭代器-vs-异步迭代器\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_5-同步迭代器-vs-异步迭代器\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" 5. 同步迭代器 vs 异步迭代器\")]),e._v(\" \"),t(\"h3\",{attrs:{id:\"_5-1-iterators\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_5-1-iterators\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" 5.1 Iterators\")]),e._v(\" \"),t(\"div\",{staticClass:\"language- line-numbers-mode\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v(\"// 迭代器interface Iterator {    next(value) : IteratorResult;    [optional] throw(value) : IteratorResult;    [optional] return(value) : IteratorResult;}// 迭代结果interface IteratorResult {    value : any;    done : bool;}\\n\")])]),e._v(\" \"),t(\"div\",{staticClass:\"line-numbers-wrapper\"},[t(\"span\",{staticClass:\"line-number\"},[e._v(\"1\")]),t(\"br\")])]),t(\"h3\",{attrs:{id:\"_5-2-async-iterators\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_5-2-async-iterators\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" 5.2 Async Iterators\")]),e._v(\" \"),t(\"div\",{staticClass:\"language- line-numbers-mode\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v(\"// 异步迭代器interface AsyncIterator {    next(value) : Promise<IteratorResult>;    [optional] throw(value) : Promise<IteratorResult>;    [optional] return(value) : Promise<IteratorResult>;}// 迭代结果interface IteratorResult {    value : any;    done : bool;}\\n\")])]),e._v(\" \"),t(\"div\",{staticClass:\"line-numbers-wrapper\"},[t(\"span\",{staticClass:\"line-number\"},[e._v(\"1\")]),t(\"br\")])]),t(\"h2\",{attrs:{id:\"_6-异步生成器函数\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_6-异步生成器函数\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" 6. 异步生成器函数\")]),e._v(\" \"),t(\"p\",[e._v(\"异步生成器函数与生成器函数类似，但有以下区别：\")]),e._v(\" \"),t(\"ul\",[t(\"li\",[e._v('当被调用时，异步生成器函数返回一个对象，\"async generator\"，含有 3 个方法（ '),t(\"code\",[e._v(\"next\")]),e._v(\"， \"),t(\"code\",[e._v(\"throw\")]),e._v(\"，和 \"),t(\"code\",[e._v(\"return\")]),e._v(\"），每个方法都返回一个 Promise，Promise 返回 \"),t(\"code\",[e._v(\"{value,done}\")]),e._v(\"。而普通生成器函数并不返回 Promise，而是直接返回 \"),t(\"code\",[e._v(\"{value,done}\")]),e._v(\"。这会自动使返回的异步生成器对象具有异步迭代的功能。\")]),e._v(\" \"),t(\"li\",[e._v(\"允许使用 \"),t(\"code\",[e._v(\"await\")]),e._v(\" 表达式和 \"),t(\"code\",[e._v(\"for-await-of\")]),e._v(\" 语句。\")]),e._v(\" \"),t(\"li\",[e._v(\"修改了 \"),t(\"code\",[e._v(\"yield*\")]),e._v(\" 的行为以支持异步迭代。\")])]),e._v(\" \"),t(\"p\",[e._v(\"示例：\")]),e._v(\" \"),t(\"div\",{staticClass:\"language- line-numbers-mode\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v(\"async function* readLines(path) {  let file = await fileOpen(path);  try {    while (!file.EOF) {      yield await file.readLine();    }  } finally {    await file.close();  }}\\n\")])]),e._v(\" \"),t(\"div\",{staticClass:\"line-numbers-wrapper\"},[t(\"span\",{staticClass:\"line-number\"},[e._v(\"1\")]),t(\"br\")])]),t(\"p\",[e._v(\"函数返回一个异步生成器（async generator）对象，可以用在 \"),t(\"code\",[e._v(\"for-await-of\")]),e._v(\" 语句中。\")]),e._v(\" \"),t(\"h2\",{attrs:{id:\"_7-实现\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_7-实现\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" 7. 实现\")]),e._v(\" \"),t(\"ul\",[t(\"li\",[e._v(\"Chakra - 暂未支持\")]),e._v(\" \"),t(\"li\",[e._v(\"JavaScriptCore - Safari Tech Preview 40\")]),e._v(\" \"),t(\"li\",[e._v(\"SpiderMonkey - Firefox 57\")]),e._v(\" \"),t(\"li\",[e._v(\"V8 - Chrome 63\")])]),e._v(\" \"),t(\"h2\",{attrs:{id:\"polyfills\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#polyfills\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" Polyfills\")]),e._v(\" \"),t(\"p\",[e._v(\"Facebook 的 Regenerator 项目为 \"),t(\"code\",[e._v(\"AsyncIterator\")]),e._v(\" 接口提供了一个 polyfill，将异步生成器函数变成返回 \"),t(\"code\",[e._v(\"AsyncIterator\")]),e._v(\" 的对象 ECMAScript 5 函数。Regenerator 还不支持 \"),t(\"code\",[e._v(\"for-await-of\")]),e._v(\" 异步迭代语法。\")]),e._v(\" \"),t(\"p\",[e._v(\"Babylon parser 项目支持异步生成器函数和 \"),t(\"code\",[e._v(\"for-await-of\")]),e._v(\" 语句（v6.8.0+）。你可以使用它的 asyncGenerators 插件。\")]),e._v(\" \"),t(\"div\",{staticClass:\"language- line-numbers-mode\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v('require(\"babylon\").parse(\"code\", {  sourceType: \"module\",  plugins: [    \"asyncGenerators\"  ]});\\n')])]),e._v(\" \"),t(\"div\",{staticClass:\"line-numbers-wrapper\"},[t(\"span\",{staticClass:\"line-number\"},[e._v(\"1\")]),t(\"br\")])]),t(\"p\",[e._v(\"另外，从 6.16.0 开始，异步迭代被包含在 Babel 的 \"),t(\"code\",[e._v('\"babel-plugin-transform-async-generator-functions\"')]),e._v(\" 下以及 \"),t(\"code\",[e._v(\"babel-preset-stage-3\")]),e._v(\"。\")]),e._v(\" \"),t(\"div\",{staticClass:\"language- line-numbers-mode\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v('require(\"babel-core\").transform(\"code\", {  plugins: [    \"transform-async-generator-functions\"  ]});\\n')])]),e._v(\" \"),t(\"div\",{staticClass:\"line-numbers-wrapper\"},[t(\"span\",{staticClass:\"line-number\"},[e._v(\"1\")]),t(\"br\")])])])}],!1,null,null,null);s.options.__file=\"ES2018 新特征之：异步迭代器 for-await-of.md\";a.default=s.exports}}]);","extractedComments":[]}